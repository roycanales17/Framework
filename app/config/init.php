<?php
	
	use Core\Config;
	
	/*
	 | Secure PHP with Configuration Settings
	 |
	 | INTRODUCTION:
	 |
	 | PHP code can be embedded in your Web pages along with HTML code.
	 | When your Web server receives a request for a page, the page is first given to the PHP
	 | handler. The PHP handler outputs HTML code without modification and executes any PHP commands.
	 | Any HTML code generated by the PHP commands is also output.
	 | This results in a Web page with content that has been customized on the server before being sent
	 | to the requester.
	 |
	 | The capabilities of PHP also make it a potential security risk because data is actively fetched,
	 | received, and processed from anywhere on the Internet.
	 | Attackers may attempt to send in malicious data and scripts and trick your server into fetching
	 | malicious scripts and running them. Attackers may also attempt to read and write files on your
	 | server to take control of the Website and use it for their own purposes.
	 |
	 | You can configure PHP settings to tighten the security of a PHP installation and help protect
	 | the Website from malicious attacks. The Php.ini file specifies the configuration settings PHP
	 | uses when it is running on your Website. The Php.ini file determines what things PHP scripts are
	 | allowed to do and what the scripts are prohibited from doing.
	 |
	 | 	allow_url_fopen 			= 	0
	 | 	allow_url_include 			= 	0
	 |  register_globals 			= 	0
	 |  open_basedir				=	"c:\inetpub"
	 |	safe_mode					=	0
	 |	safe_mode_gid				=	0
	 |	max_execution_time			=	30
	 |	max_input_time				=	60
	 |	memory_limit				=	16M
	 |	upload_max_filesize			=	2M
	 |	post_max_size				=	8M
	 |	max_input_nesting_levels	=	64
	 |	display_errors				=	0
	 |	log_errors					=	0
	 |	error_log 					=	"C:\path\of\your\choice.log"
	 |	fastcgi.logging				=	0
	 |	expose_php					=	0
	 |
	*/
	
	return [
		
		/*
	    |--------------------------------------------------------------------------
	    | Default Application Settings
	    |--------------------------------------------------------------------------
	    |
	    | Here you may specify what settings you want to apply before starting
	    | the application.
	    |
	    */
		'xdebug_config' => 	[
			'var_display_max_depth' 	=> -1,
			'var_display_max_children' 	=> -1,
			'var_display_max_data' 		=> -1
		],
		
		/*
		 * By setting the session cookie lifetime to 0, you're essentially telling the browser to discard the cookie when it's closed,
		 * effectively ending the session.
		 *
		 * This ensures that sessions are not persisted beyond the lifetime of the browser session.
		 */
		'session_set_cookie_params' => 0,
		
		/*
		 * SESSION CONFIGURATION
		 */
		'session_config' => [
			/*
			 | session_name:
			 | Returns the name of the current session. If name is given, session_name() will update the
			 | session name and return the old session name.
			*/
			'session_name' => 'SESSION_FRAMEWORK',
			/*
			 | Sessions or session handling is a way to make the data available across various pages of a web application.
			 | The session_save_path() is used to set or retrieve the path where the current session data is saved.
			*/
			'save_path' => Config::get( "CACHE_PATH" ),
			/*
			 | session_regenerate_id:
			 | will replace the current session id with a new one, and keep the current session information.
			*/
			'session_regenerate_id' => false,
			/*
			 | gc_maxlifetime & cookie_lifetime:
			 | Session expiration.
			*/
			'gc_maxlifetime' => 1440,
			/*
			 | use_only_cookies:
			 | Although HTTP cookies suffer some problems, cookies remain the preferred way to manage session IDs.
			 | Only use cookies for session ID management when it is possible. Most applications should use a cookie
			 | for the session ID. If session.use_only_cookies=Off, the session module will use the session ID values
			 | set by GET/POST/URL provided the session ID cookie is uninitialized. This will return FALSE if
			 | `session_start()` has already been called.
			*/
			'use_cookies' => 1,
			'use_only_cookies' => 1,
			/*
			 | cookie_lifetime:
			 | 0 possesses a particular meaning. It informs browsers not to store the cookie to permanent storage.
			 | Therefore, when the browser is terminated, the  session ID cookie is deleted immediately. If
			 | developers set this other than 0, it may allow other users to use the session ID. Most applications
			 | should use "0" for this.
			 |
			 | Due to the cookie specification, attackers are capable to place non-removable session ID cookies by
			 | locally setting a cookie database or JavaScript injections. session.use_strict_mode can prevent
			 | an attacker initialized session ID of being used.
			*/
			'cookie_lifetime' => 0,
			/*
			 | use_strict_mode:
			 | Although, enabling session.use_strict_mode is mandatory for secure sessions. It is disabled by resources.
			 | This prevents the session module to use an uninitialized session ID. Put differently, the session
			 | module only accepts valid session IDs generated by the session module. It rejects any session ID
			 | supplied by users.
			*/
			'use_strict_mode' => 1,
			/*
			 | cookie_httponly:
			 | Refuses access to the session cookie from JavaScript. This setting prevents cookies snatched by a
			 | JavaScript injection. It is possible to use a session ID as a CSRF token, but this is not recommended.
			 | For example, HTML sources may be saved and sent to other users. Developers should not write session IDs
			 | in web pages for better security. Almost all applications must use the httponly attribute for the session
			 | ID cookie.
			*/
			'cookie_httponly' => 1,
			/*
			 | cookie_secure:
			 | Allow access to the session ID cookie only when the protocol is HTTPS. If a website is only accessible
			 | via HTTPS, it should enable this setting.
			 | HSTS should be considered for websites accessible only via HTTPS.
			*/
			'cookie_secure' => 1,
			/*
			 | cookie_samesite:
			 | As of PHP 7.3 the "SameSite" attribute can be set for the session ID cookie. This attribute is a way
			 | to mitigate CSRF (Cross Site request Forgery) attacks. The difference between Lax and Strict is the
			 | accessibility of the cookie in requests originating from another registrable domain employing the HTTP GET method.
			 | Cookies using Lax will be accessible in a GET request originated from another registrable domain,
			 | whereas cookies using Strict will not.
			*/
			'cookie_samesite' => "Lax", # enum=Strict;Lax;
			/*
			 | use_trans_sid:
			 | Use of a transparent session ID management is not prohibited. Developers may employ it when it is required.
			 | However, disabling transparent session ID management improves the general session ID security by eliminating
			 | the possibility of a session ID injection and/or leak.
			*/
			'use_trans_sid' => 0,
			/*
			 | hash_bits_per_character:
			 | (PHP 7.1.0 >=) The more bits there are in a session ID character, the stronger the session ID generated by
			 | the session module is for an identical session ID length.
			*/
			'hash_bits_per_character' => 5,
			/*
			 | hash_function:
			 | (PHP 7.1.0 <) A stronger hash function will generate a stronger session ID. Although hash collision is unlikely
			 | even with the MD5 hashing algorithm, developers should use SHA-2 or a stronger hashing algorithm like sha384 and
			 | sha512. Developers must ensure they feed a long enough entropy for the hashing function used.
			*/
			'hash_function' => 'sha256',
			/*
			 | cookie_domain:
			 | session.cookie_domain specifies the domain to set in the session cookie. Default is none at all meaning the host
			 | name of the server which generated the cookie according to cookies specification
			*/
			//'cookie_domain'				=>	':HOST', [ This must be accurate ]
			'entropy_length' => 32,
			'entropy_file' => '/dev/urandom',
		],
	];